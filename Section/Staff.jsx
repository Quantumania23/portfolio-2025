/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Enhanced with magical animations
*/
"use client";
import React, { useRef, useState, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

// Magical particle system
const MagicalParticles = ({ trigger, staffPosition }) => {
  const particlesRef = useRef();
  const particleCount = 50;
  const [particles] = useState(() => {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const lifetimes = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      // Start near the staff tip
      positions[i3] = (Math.random() - 0.5) * 0.2;
      positions[i3 + 1] = Math.random() * 0.5;
      positions[i3 + 2] = (Math.random() - 0.5) * 0.2;

      // Random velocities
      velocities[i3] = (Math.random() - 0.5) * 0.02;
      velocities[i3 + 1] = Math.random() * 0.03 + 0.01;
      velocities[i3 + 2] = (Math.random() - 0.5) * 0.02;

      // Magical colors (purple, blue, gold)
      const colorType = Math.random();
      if (colorType < 0.33) {
        colors[i3] = 0.6; colors[i3 + 1] = 0.2; colors[i3 + 2] = 0.8; // Purple
      } else if (colorType < 0.66) {
        colors[i3] = 0.2; colors[i3 + 1] = 0.6; colors[i3 + 2] = 1.0; // Blue
      } else {
        colors[i3] = 1.0; colors[i3 + 1] = 0.8; colors[i3 + 2] = 0.2; // Gold
      }

      sizes[i] = Math.random() * 0.01 + 0.005;
      lifetimes[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    return {
      geometry,
      positions,
      velocities,
      lifetimes,
      material: new THREE.PointsMaterial({
        size: 0.01,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      })
    };
  });

  useFrame((state, delta) => {
    if (!particlesRef.current || !trigger) return;

    const positions = particles.positions;
    const velocities = particles.velocities;
    const lifetimes = particles.lifetimes;

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      
      // Update lifetime
      lifetimes[i] -= delta * 2;
      
      if (lifetimes[i] <= 0) {
        // Reset particle at staff tip
        positions[i3] = staffPosition[0] + (Math.random() - 0.5) * 0.2;
        positions[i3 + 1] = staffPosition[1] + 1.5 + Math.random() * 0.5;
        positions[i3 + 2] = staffPosition[2] + (Math.random() - 0.5) * 0.2;
        lifetimes[i] = Math.random() + 0.5;
      } else {
        // Update position
        positions[i3] += velocities[i3];
        positions[i3 + 1] += velocities[i3 + 1];
        positions[i3 + 2] += velocities[i3 + 2];
        
        // Add some swirl motion
        const time = state.clock.elapsedTime;
        positions[i3] += Math.sin(time * 3 + i * 0.1) * 0.001;
        positions[i3 + 2] += Math.cos(time * 3 + i * 0.1) * 0.001;
      }
    }

    particles.geometry.attributes.position.needsUpdate = true;
    
    // Fade particles based on trigger
    particles.material.opacity = trigger ? 
      Math.min(particles.material.opacity + delta * 3, 0.8) : 
      Math.max(particles.material.opacity - delta * 2, 0);
  });

  return (
    <points ref={particlesRef} geometry={particles.geometry} material={particles.material} />
  );
};

const Staff = React.memo(function Staff({ onHover = false, ...props }) {
  const { nodes, materials } = useGLTF("/Models/staff-transformed.glb");
  const modelRef = useRef();
  const [animationState, setAnimationState] = useState('idle');
  const { camera } = useThree();
  
  // Animation targets
  const baseRotation = useRef({ x: 0, y: 0, z: 0 });
  const targetRotation = useRef({ x: 0, y: 0, z: 0 });
  const basePosition = useRef({ x: 0, y: -2, z: 0 });
  const targetPosition = useRef({ x: 0, y: -2, z: 0 });
  const animationProgress = useRef(0);
  const glowIntensity = useRef(0);

  // Magic spell effects
  const [showParticles, setShowParticles] = useState(false);
  const [staffPosition, setStaffPosition] = useState([0, -2, 0]);

  useEffect(() => {
    if (onHover && animationState === 'idle') {
      // Start casting animation
      setAnimationState('casting');
      setShowParticles(true);
      
      // Staff movement animation
      targetPosition.current = { x: 0.5, y: -1.5, z: 1 };
      targetRotation.current = { 
        x: -Math.PI / 6, 
        y: Math.PI / 4, 
        z: Math.PI / 12 
      };
      animationProgress.current = 0;
      
      // Return to idle after animation
      setTimeout(() => {
        if (animationState === 'casting') {
          setAnimationState('returning');
          targetPosition.current = { x: 0, y: -2, z: 0 };
          targetRotation.current = { x: 0, y: 0, z: 0 };
          animationProgress.current = 0;
          
          setTimeout(() => {
            setAnimationState('idle');
            setShowParticles(false);
          }, 1000);
        }
      }, 1500);
    }
  }, [onHover, animationState]);

  useFrame((state, delta) => {
    if (!modelRef.current) return;

    const time = state.clock.elapsedTime;
    
    if (animationState === 'idle') {
      // Gentle floating rotation
      modelRef.current.rotation.y += 0.007;
      modelRef.current.position.y = basePosition.current.y + Math.sin(time * 2) * 0.1;
      glowIntensity.current = Math.max(0, glowIntensity.current - delta * 2);
    } else {
      // Animation lerping
      animationProgress.current = Math.min(1, animationProgress.current + delta * 2);
      const progress = animationProgress.current;
      
      // Easing function for smooth animation
      const easeInOutCubic = progress < 0.5 
        ? 4 * progress * progress * progress 
        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      
      // Interpolate position
      modelRef.current.position.x = THREE.MathUtils.lerp(
        basePosition.current.x, 
        targetPosition.current.x, 
        easeInOutCubic
      );
      modelRef.current.position.y = THREE.MathUtils.lerp(
        basePosition.current.y, 
        targetPosition.current.y, 
        easeInOutCubic
      );
      modelRef.current.position.z = THREE.MathUtils.lerp(
        basePosition.current.z, 
        targetPosition.current.z, 
        easeInOutCubic
      );
      
      // Interpolate rotation
      modelRef.current.rotation.x = THREE.MathUtils.lerp(
        baseRotation.current.x, 
        targetRotation.current.x, 
        easeInOutCubic
      );
      modelRef.current.rotation.y = THREE.MathUtils.lerp(
        baseRotation.current.y, 
        targetRotation.current.y, 
        easeInOutCubic
      );
      modelRef.current.rotation.z = THREE.MathUtils.lerp(
        baseRotation.current.z, 
        targetRotation.current.z, 
        easeInOutCubic
      );

      // Add some magical trembling during casting
      if (animationState === 'casting') {
        modelRef.current.position.x += Math.sin(time * 20) * 0.02;
        modelRef.current.position.y += Math.cos(time * 25) * 0.01;
        glowIntensity.current = Math.min(1, glowIntensity.current + delta * 3);
      }

      // Update animation base when complete
      if (progress >= 1) {
        basePosition.current = { ...targetPosition.current };
        baseRotation.current = { ...targetRotation.current };
      }
    }

    // Update staff position for particles
    const worldPosition = new THREE.Vector3();
    modelRef.current.getWorldPosition(worldPosition);
    setStaffPosition([worldPosition.x, worldPosition.y, worldPosition.z]);

    // Magical glow effect on materials
    if (materials.Wizard_Staff3 && materials.Wizard_Staff2) {
      const glowColor = new THREE.Color().setHSL(0.75, 1, 0.5 + glowIntensity.current * 0.3);
      materials.Wizard_Staff3.emissive = glowColor.multiplyScalar(glowIntensity.current * 0.2);
      materials.Wizard_Staff2.emissive = glowColor.multiplyScalar(glowIntensity.current * 0.15);
    }
  });

  return (
    <group {...props} dispose={null}>
      <group
        scale={[3, 3, 3]}
        position={[0, -2, 0]}
        ref={modelRef}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Wizard_Staff3_Wizard_Staff3_0.geometry}
          material={materials.Wizard_Staff3}
          position={[-0.041, 0.983, 0.768]}
          rotation={[0, Math.PI / 2, 0]}
          scale={0.04}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Wizard_Staff3_Wizard_Staff3_0_1.geometry}
          material={materials.Wizard_Staff3}
          position={[-0.041, 0.983, 0.768]}
          rotation={[0, Math.PI / 2, 0]}
          scale={0.04}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Wizard_Staff3_Wizard_Staff3_0_2.geometry}
          material={materials.Wizard_Staff3}
          position={[-0.041, 0.983, 0.768]}
          rotation={[0, Math.PI / 2, 0]}
          scale={0.04}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Wizard_Staff3_Wizard_Staff3_0_3.geometry}
          material={materials.Wizard_Staff3}
          position={[-0.041, 0.983, 0.768]}
          rotation={[0, Math.PI / 2, 0]}
          scale={0.04}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Wizard_Staff2_Wizard_Staff2_0.geometry}
          material={materials.Wizard_Staff2}
          position={[-0.041, 0.983, 0.768]}
          rotation={[0, Math.PI / 2, 0]}
          scale={0.04}
        />
      </group>
      
      {/* Magical Particles */}
      <MagicalParticles trigger={showParticles} staffPosition={staffPosition} />
      
      {/* Magical aura/glow ring */}
      {showParticles && (
        <mesh position={staffPosition} rotation={[Math.PI / 2, 0, 0]}>
          <ringGeometry args={[0.3, 0.5, 32]} />
          <meshBasicMaterial 
            color={new THREE.Color().setHSL(0.75, 1, 0.6)}
            transparent
            opacity={0.3}
            side={THREE.DoubleSide}
          />
        </mesh>
      )}
    </group>
  );
});

export default Staff;
useGLTF.preload("/models/staff-transformed.glb");